#!/usr/bin/python

# To access file system and allow for switches
import os, sys
import argparse

# Numerical methods libaries and plotting
import numpy as np
from matplotlib import pyplot as plt
from scipy.optimize import newton


from test_suite import test

##-------------------Command Line Interface----------------------------------

'''
MOS-SIM Executable

This file conatins the main function for the MOS-SIM Executable.
To run this file file with the appropriate tests, run

"mos-sim test"

To run a custom sweep run the follwing, and follow the on-screen instructions. 

"mos-sim"

'''

def main(argv):

	parser = argparse.ArgumentParser(description='MOSFET Simulation Code.')
	parser.add_argument('-t', '--test', help='Run tests.', action="store_true")
	args = parser.parse_args()

	if args.test:

		# Instantiate a new FET
		mosfet = MOSFET(-0.8, 5*(10**17), 2.5, 10.0, 10.0, 400)

		# Model it
		mosfet.model(0.0, [0, 2.5], [1.8])


##-------------------Constants (Global Variables)----------------------------

q = 1.602*(10**(-19))			# Coulombs
epsilonSi = 1.05*(10**(-12)) 	# Semiconductor Units
thermalVoltage = 0.026 			# Volts
intrinsicCarriers = 10**10		# cm^-3


##-------------------Source Code (as opposed to Drain Code)------------------

'''
MOSFET Class

sourceBody: 	float 	representing the sourceBody bias
drainSource: 	float	representing drainSource voltage bias
gateSource: 	float 	representing gateSource votlage bias

'''

class MOSFET(object):

	def __init__(self, flatband, acceptorDoping, oxideThickness, width, length, mobility, dataPoints = 1000):

		# Given parameters
		self.flatband = flatband
		self.width = width
		self.length = length
		self.mobility = mobility

		# Derived parameters
		self.oxideCapacitance = epsilonSi / (oxideThickness*(10**-7))
		self.fermiPotential = thermalVoltage*np.log(acceptorDoping/intrinsicCarriers)
		self.bodyCoeff = 0.53*(oxideThickness/10.0)*np.sqrt(acceptorDoping/(10**17))

		# Default simulation parameters
		self.dataPoints = dataPoints


	def model(self, sourceBody, drainSource, gateSource):

		drainSourceRange = np.linspace(drainSource[0], drainSource[1], self.dataPoints)
		psiRange = np.linspace(drainSource[0] + sourceBody, drainSource[1] + sourceBody, self.dataPoints)

		diffVectorized = np.vectorize(self.diffusionCurrent)
		driftVectorized = np.vectorize(self.driftCurrent)

		drainSourceCurrents = []

		for i in range(len(gateSource)):

			# Redefine voltages
			self.sourceBody = sourceBody
			self.gateBody = gateSource[i] + sourceBody

			# Calculate and memoize surface potentials
			self.calculateSeriesExpansion(psiRange)

			# Compute current compoenents and graph
			diff = diffVectorized(self.potentials)
			drift = driftVectorized(self.potentials)

			drainSourceCurrent = np.add(diff, drift)

			drainSourceCurrents.append(drainSourceCurrent)

		for i in range(len(drainSourceCurrents)):
			plt.plot(drainSourceRange, drainSourceCurrents[i])

		plt.show()
	
		return 

	def diffusionCurrent(self, psiL):
		
		mobilityComponent = (self.width/self.length)*self.mobility*self.oxideCapacitance*self.alpha*thermalVoltage
		drainComponent = psiL - self.potentials[0]

		return mobilityComponent*drainComponent

	def driftCurrent(self, psiL):
		
		mobilityComponent = (self.width/self.length)*self.mobility*self.oxideCapacitance
		thresholdComponent = self.gateBody - self.flatband - self.expansion - self.bodyCoeff*np.sqrt(self.expansion)
		drainComponent = psiL - self.potentials[0]

		return mobilityComponent*thresholdComponent*drainComponent

	# Direct calculation of surface potential via newton-raphson
	def surfacePotential(self, contactBody):

		self.contactBody = contactBody
		return newton(self.implicitPotential, 0, maxiter=10000)

	# Implicit anonymous function
	def implicitPotential(self, psi):

		return self.gateBody - self.flatband - psi - self.bodyCoeff*np.sqrt(psi + thermalVoltage*np.exp((psi - 2*self.fermiPotential - self.contactBody)/thermalVoltage))

	def calculateSeriesExpansion(self, psiRange):

		spVectorized = np.vectorize(self.surfacePotential)

		self.potentials = spVectorized(psiRange)
		self.expansion = (self.potentials[-1] + self.potentials[0])/2.0
		self.alpha = 1.0 + (self.bodyCoeff/(2.0*np.sqrt(self.expansion)))

		a = self.surfacePotential(0.1)
		b = self.implicitPotential(a)
		print a, b

		return


	'''
	Function to plot MOSFET data.

	sourceBody: 	float 	representing the sourceBody bias
	drainSource: 	2-tuple representing drainSource voltage range
	gateSource: 	2-tuple representing gateSource votlage range

	'''
	def plotModel(self, sourceBody, drainSourceRange, gateSourceRange):
		return




if __name__ == "__main__":
   main(sys.argv[1:])